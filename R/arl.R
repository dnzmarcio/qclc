#' Calibration Parameters for Moving Average statistic
#'
#' \code{arl_ma()} returns estimates of the Operating Characteristics for the 
#' the Moving Average quality control charts through bootstrap sampling. 
#'
#' @param x A numeric vector of individual observations obtained from the process.
#' In some cases, \code{x} can also indicate sample averages according to a specified sampling plan.
#' @param mu double; process mean. Also known as the target mean or the average of the historical data.
#' @param sigma2 double; estimate of the process variance.
#' @param L A numeric value or vector. \code{L} is a control limit factor; represents 
#' the width of the control limits in terms of multiples of the standard deviation.
#' @param omega integer; the weighting factor of MA charts.
#' @param max.rl integer; Maximum Run Length. It refers to the total number of 
#' observations to be collected from \code{x} in each process replicate.
#' @param rl integer; Run Length of interest. It indicates the number of observations to detect an out-of-control condition. 
#' @param scenario A logical evaluating to 0 or 1 indicating whether the process is under control \code{scenario} = 0, or the process out of control \code{scenario} = 1.
#' @param nboot integer; number of simulations to generate the process replicates.
#' @param ncores integer; number of CPU cores to use for parallel processing. 
#' @param seed integer; to initialize the Random Number Generator to a known state.
#'
#' @return Returns a data frame containing the Operating Characteristics for MA charts. 
#' The data frame includes the following columns:
#' \itemize{
#'   \item \code{L}: Control Limit Factor.
#'   \item \code{ARL}: Average Run Length. See Details for more information about ARL0 and ARL1.
#'   \item \code{FP}: False Positive rate, representing the frequency of false alarms when the process is in control. 
#'   \item \code{TP}: True Positive rate, indicating the rate of correctly detecting a shift when the process is actually out of control.
#' }
#' 
#' 
#' @export
#'
#' @details
#' \code{ARL} is the expected Run Length \code{rl} generated by \code{arl_ewma}. 
#' When the process is under control \code{scenario = 0}, Average Run Length is denoted as
#' \code{ARL0} and \code{FP} is returned. If the process is out of control 
#' \code{scenario = 1}, Average Run Length is used as \code{ARL1} and \code{TP} is 
#' returned. 
#' 
#' \code{ARL0} and \code{ARL1} refer to the expected number of observations to 
#' detect an out-of-control condition. When the process is under control, a high \code{ARL0} is 
#' preferred as it demonstrates that the chart does not react excessively to regular 
#' variations within process limits, thus minimizing false alarms. Conversely, a low \code{ARL1} 
#' is desirable because it signifies that the chart is adequately sensitive, 
#' enabling quick detection and response to actual deviations in the process. This 
#' increases the true positive rate, hence the power of the quality control charts.
#' 
#' @examples 
#' ## process under control
#' x <- rnorm(100)
#' omega = 10
#' max.rl = 110
#' aux = control_parm_ma(x, omega)
#' arl_ma(x, mu = aux$mu, aux$sigma2, omega = aux$omega, 
#'        L = seq(1, 3, by = 0.25), 
#'        max.rl = 110, rl = 100, 
#'        scenario = 0, nboot = 100, 
#'        ncores = 1, seed = 1234)
#'        
#' ## process out of control (shift in the mean by 0.5 standard deviation)
#' x <- rnorm(100)
#' x.shift = x + 0.5*(sqrt(var(x)))
#' omega = 10
#' max.rl = 110 
#' aux = control_parm_ma(x, omega)
#' arl_ma(x.shift, mu = aux$mu, aux$sigma2, omega, 
#'        L = seq(1, 3, by = 0.25), 
#'        max.rl = 110, rl = 100, 
#'        scenario = 1, nboot = 100, 
#'        ncores = 1, seed = 1234)

arl_ma <- function(x, mu, sigma2, omega,
                   L = seq(1, 3, by = 0.25), 
                   max.rl = 10000, rl = 100,
                   scenario = 0,
                   nboot = 100, ncores = 1, seed = 1234){
  
  registerDoParallel(ncores)
  
  rl.tab <- matrix(NA, ncol = (3 + length(rl)), nrow = length(L))
  
  
  for (i in 1:length(L)){
    #print(i)
    upper <- mu + L[i]*sqrt(sigma2[c(1:(omega-1), rep(omega, (max.rl - omega + 2)))])
    lower <- mu - L[i]*sqrt(sigma2[c(1:(omega-1), rep(omega, (max.rl - omega + 2)))])
    
    rl.tab[i, 1] <- L[i]
    
    set.seed(seed)
    rl.temp <- foreach (j = 1:nboot, .combine = `c`) %dopar% {
                           x.boot <- sample(x, size = max.rl, replace = TRUE)
                           statistic <- ma_statistic(x = x.boot, t = 1:max.rl, omega = omega)
                           
                           aux <- which(statistic < lower | statistic > upper)[1]
                           
                           if (!is.na(aux)){
                             out <- aux
                           } else {
                             out <- max.rl
                           }
                         }
    
    rl.tab[i, 2] <- mean(rl.temp[!is.na(rl.temp)], na.rm = TRUE)
    
    rl.tab[i, 3:(3+length(rl)-1)] <-
      sapply(rl, function(t) mean(rl.temp < t | is.na(rl.temp), na.rm = TRUE))
    
    rl.tab[i, (3+length(rl))] <- length(rl.temp[!is.na(rl.temp)])
  }
  stopImplicitCluster()
  
  if (scenario == 0){
    colnames(rl.tab) <- c("L", "Arl0", paste0("FP_", rl), "nboot")
  } else {
    colnames(rl.tab) <- c("L", "arl1", paste0("TP_", rl), "nboot")
  }
  
  return(rl.tab)
}


#' Calibration Parameters for Exponentially Weighted Moving Average statistic 
#'
#' \code{arl_ewma()} returns estimates of the Operating Characteristics for the 
#' the Exponential Weighted Moving Average quality control charts through 
#' bootstrap sampling. 
#' 
#' @param x A numeric vector of individual observations obtained from the process.
#' In some cases, \code{x} can also indicate sample averages according to a specified sampling plan.
#' @param mu double; process mean. Also known as the target mean or the average of the historical data.
#' @param sigma2 double; estimate of the process variance.
#' @param L A numeric value or vector. \code{L} is a control limit factor; represents 
#' the width of the control limits in terms of multiples of the standard deviation.
#' @param lambda A numeric value between 0 and 1 inclusive that indicates the weighting factor of EWMA charts.
#' @param max.rl integer; Maximum Run Length. It refers to the total number of observations to be collected from \code{x} in each process replicate.
#' @param rl integer; Run Length of interest. It indicates the number of observations to detect an out-of-control condition. 
#' @param scenario A logical evaluating to 0 or 1 indicating whether the process is under control \code{scenario} = 0, or the process out of control \code{scenario} = 1.
#' @param nboot integer; number of simulations to generate the process replicates.
#' @param ncores integer; number of CPU cores to use for parallel processing. 
#' @param seed integer; to initialize the Random Number Generator to a known state.
#'
#'
#' @return Returns a data frame containing the Operating Characteristics for EWMA charts. 
#' The data frame includes the following columns:
#' \itemize{
#'   \item \code{L}: Control Limit Factor.
#'   \item \code{ARL}: Average Run Length. See Details for more information about ARL0 and ARL1.
#'   \item \code{FP}: False Positive rate, representing the frequency of false alarms when the process is in control. 
#'   \item \code{TP}: True Positive rate, indicating the rate of correctly detecting a shift when the process is actually out of control.
#' }
#' 
#' @export
#' 
#' @details
#' \code{ARL} is the expected Run Length \code{rl} generated by \code{arl_ewma()}. 
#' When the process is under control \code{scenario = 0}, Average Run Length is denoted as
#' \code{ARL0} and \code{FP} is returned. If the process is out of control 
#' \code{scenario = 1}, Average Run Length is used as \code{ARL1} and \code{TP} is 
#' returned. 
#' 
#' \code{ARL0} and \code{ARL1} refer to the expected number of observations to 
#' detect an out-of-control condition. When the process is under control, a high \code{ARL0} is 
#' preferred as it demonstrates that the chart does not react excessively to regular 
#' variations within process limits, thus minimizing false alarms. Conversely, a low 
#' \code{ARL1} is desirable because it signifies that the chart is adequately sensitive, 
#' enabling quick detection and response to actual deviations in the process. This 
#' increases the true positive rate, hence the power of the quality control charts.
#'  
#' @examples 
#' x <- rnorm(100)
#' lambda = 0.2
#' max.rl = 110
#' aux = control_parm_ewma(x, lambda, max.rl)
#' 
#' ## process under control
#' arl_ewma(x, mu = aux$mu, aux$sigma2, lambda = aux$lambda, 
#'          L = seq(1, 3, by = 0.25), 
#'          max.rl = 110, rl = 100, 
#'          scenario = 0, nboot = 100, 
#'          ncores = 1, seed = 1234)
#'          
#' ## process out of control (shift in the mean by 0.5 standard deviation)
#' x <- rnorm(100) 
#' lambda = 0.2
#' max.rl = 110
#' x.shift = x + 0.5*(sqrt(var(x))) 
#' aux = control_parm_ewma(x, lambda, max.rl)
#' arl_ewma(x = x.shift, mu = aux$mu, aux$sigma2, lambda, 
#'          L = seq(1, 3, by = 0.25), 
#'          max.rl = 110, rl = 100, 
#'          scenario = 1, nboot = 100, 
#'          ncores = 1, seed = 1234)


arl_ewma <- function(x, mu, sigma2, lambda,
                     L = seq(1, 3, by = 0.25), 
                     max.rl = 10000, rl = 100,
                     scenario = 0,
                     nboot = 100, ncores = 1, seed = 1234){
  
  registerDoParallel(ncores)
  
  rl.tab <- matrix(NA, ncol = (3 + length(rl)), nrow = length(L))
  
  for (i in 1:length(L)){
    #print(i)
    upper <- mu + L[i]*sqrt(sigma2)
    lower <- mu - L[i]*sqrt(sigma2)
    
    rl.tab[i, 1] <- L[i]
    
    set.seed(seed)
    rl.temp <- foreach (j = 1:nboot, .combine = `c`) %dopar% {
                           x.boot <- sample(x, size = max.rl, replace = TRUE)
                           statistic <- ewma_statistic(x = x.boot, t = 1:max.rl, lambda = lambda, x0 = mu)
                           
                           aux <- which(statistic < lower | statistic > upper)[1]
                           
                           if (!is.na(aux)){
                             out <- aux
                           } else {
                             out <- max.rl
                           }
                         }
    
    rl.tab[i, 2] <- mean(rl.temp[!is.na(rl.temp)], na.rm = TRUE)
    
    rl.tab[i, 3:(3+length(rl)-1)] <- 
      sapply(rl, function(t) mean(rl.temp < t | is.na(rl.temp), na.rm = TRUE))
    
    rl.tab[i, (3+length(rl))] <- length(rl.temp[!is.na(rl.temp)])
  }
  stopImplicitCluster()
  
  if (scenario == 0){
    colnames(rl.tab) <- c("L", "Arl0", paste0("FP_", rl), "nboot")
  } else {
    colnames(rl.tab) <- c("L", "Arl1", paste0("TP_", rl), "nboot")
  }
  
  return(rl.tab)
}


